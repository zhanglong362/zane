python 4-16 笔记

回顾
1. 新式类与经典类
    1）新式类：
        1）继承object的类，以及该类的子类；
        2）python3 中全都是新式类；
    2）经典类：
        1）没有继承object的类，以及该类的子类；
        2）只有python2中才有经典类，在python2中没有继承任何类的类，不会默认继承object类；
    3）新式类与经典类的区别：
        只有在菱形继承的背景下才有区别：
        新式类：广度优先；
        经典类：深度优先；
    4）查找属性的列表：（mro方法）
        Foo.mro()
2. 继承
    1）什么是继承？
        继承是一种新建类的方式，新建的类称为子类或派生类；父类又称为基类或超类；
        子类可以“遗传”父类的属性，从可以减少代码冗余；
        如何寻找继承关系？
        先抽象，再继承，继承描述的就是一种父子关系/从属关系。
        继承的语法：
        class Foo1:
            pass
        class Foo2:
            pass
        class Bar(Foo1, Foo2):
            pass
    2）组合
        作用：
            组合与继承的作用一样，都是用来减少类与类之间的重复代码；

        定义：
            A类的对象具有某一个属性，该属性的值是B类的对象；
            基于这种方式就把A类与B类组合在一起；
            对象既能使用A类的中的数据与功能，也能使用B类中的数据与功能；
    3）在子类定义的方法中重用父类的功能：
        a. 不依赖继承：(指名道姓调用某一个类的函数，与继承无关)
            class.function(*args)                   
        b. 严格依赖继承：
            super().function(*args)
3. 封装
    1）什么是封装？
        封装（从字母意思理解）就是隐藏，隐藏指的是一类内部将一个属性隐藏起来，
        让类外部的使用者无法直接使用，在py中就是用__开头将一个属性隐藏起来。
    2）补充说明：
        封装绝对不是单纯意义的隐藏；
        须知定义属性的意义就是为了让使用者去用，使用者要想使用类内部隐藏的属性，
        需要类的设计者在类内部开一个接口（定义一个方法），在该方法内访问隐藏的属性，
        使用者以后就通过该方法来间接地访问，内部隐藏的属性；
        作为类设计者可以在接口之上附加任意逻辑，从而严格控制类的使用者对属性的操作；
    3）封装函数的属性的目的：隔离复杂度；
        class People:
            def __init__(self, name):
                self.__name = name

            def tell_name(self):
                return self.__name

        obj = People('egon')
        obj.tell_name()

新笔记
1. property装饰器
    作用：property的作用就是把一个类的方法变成属性调用；
    特点：这种特性的使用方式遵循了类的统一访问的原则；
    例子：
        class People:
            def __init__(self, name, weight, height):
                self.name = name
                self.weight = weight
                self.height = height

            @property
            def bmi(self):
                print('获取属性 name ..')
                return self.weight / (self.height ** 2)

            @name.setter
            def name(self,name):
                print('修改属性 name ..')
                if type(name) is not str:
                    raise TypeError('名字必须是str类型')
                self.__name=name
                print(111)

            @name.deleter
            def name(self):
                print('删除属性 name ..')
                del  self.__name

        egon = People('egon', 80, 1.74)
        alex = People('alex', 69, 1.70)
        print(egon.bmi)
        print(alex.bmi)
        egon.weight = 100
        print(egon.bmi)

        obj = People('egon', 80, 1.74)
        print(obj.name)
        obj.name = '123'
        print(obj.name)
        del obj.name
        print(obj.name)

2. 多态
    1）什么是多态？
        含义：
            多态指的是同一种事物的多种形态；
        实现方式：
            1）首先定义抽象类，只需声明抽象方法，不需要实现；
            2）再定义抽象方法，由子类去具体实现抽象方法；
        注意：
            抽象基类本身不能被实例化；
    2）为什么要用多态？
        用基类创建一套统一的规则，强制子类去遵循（使用抽象类实现），这样可以在不考虑对象的具体类型的前提下，直接使用对象的方法（多态性）；
    3）如何用多态？
        动物的多种形态：猫、狗、猪
        动物技能的派生：喵喵喵、汪汪汪、哼哼哼
        例子：
        import abc

        class Animal(metaclass=abc.ABCMeta):
            def eat(self):
                pass

            def drink(self):
                pass

            def run(self):
                pass

            @abc.abstractmethod
            def bark(self):
                pass

        class Cat(Animal):
            def bark(self):
                print('喵喵喵')


        class Dog(Animal):
            def bark(self):
                print('汪汪汪')


        class Pig(Animal):
            def bark(self):
                print('哼哼哼')

        c = Cat()
        c.bark()

3. 类的方法
    在类内部定义的函数，默认就是绑定给对象来用的，称为对象的绑定方法；
    1）绑定给对象的方法：
        应该由对象来调用，会自动把对象当做第一个参数传入；
        类调用比较麻烦，需要把对象作为第一个参数传入；
        例子：
            class People:
                def __init__(self, name, age):
                    self.name = name
                    self.age = age

                def tell(self):
                    print('name: %s age: %s' % (self.name, self.age))

            p = People('egon',18)
            p.tell()

    2）绑定给类的方法：（classmethd）
        应该由类调用，会自动把类当做第一个参数传入；
        例子：
            name = 'egon'
            age = 18

            class People:
                def __init__(self, name, age):
                    self.name = name
                    self.age = age

                def tell(self):
                    print('name: %s age: %s' % (self.name, self.age))

                @classmethod
                def tell_classmethod(cls):
                    return cls('name: %s age: %s' % (name, age))

            p = People.tell_classmethod()
            p.tell()

    3）非绑定方法：(staticmethod)
        对象和类都可以调用，就是一个普通函数，调用不会自动传参数；
        例子：
            import  hashlib
            import time

            class People:
                def __init__(self, name, age):
                    self.name = name
                    self.age = age
                    self.uid = self.create_id()

                def tell(self):
                    print('ID: %s name: %s age: %s' % (self.uid, self.name, self.age))

                @staticmethod 
                def create_id():
                    m = hashlib.md5()
                    m.update(str(time.clock()).encode('utf-8'))
                    return m.hexdigest()

            对象使用：
                obj=People('egon',18)
                obj.tell()
            类使用：
                People.tell()

